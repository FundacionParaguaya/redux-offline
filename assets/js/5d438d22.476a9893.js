"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[613],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return d}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,a=e.originalType,s=e.parentName,u=l(e,["components","mdxType","originalType","parentName"]),p=c(n),d=i,m=p["".concat(s,".").concat(d)]||p[d]||f[d]||a;return n?r.createElement(m,o(o({ref:t},u),{},{components:n})):r.createElement(m,o({ref:t},u))}));function d(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var a=n.length,o=new Array(a);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,o[1]=l;for(var c=2;c<a;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},763:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var r=n(7462),i=n(3366),a=(n(7294),n(3905)),o=["components"],l={sidebar_position:3,title:"Write Resilience"},s=void 0,c={unversionedId:"basics/write-resilience",id:"basics/write-resilience",isDocsHomePage:!1,title:"Write Resilience",description:"That's all she wrote",source:"@site/docs/basics/write-resilience.md",sourceDirName:"basics",slug:"/basics/write-resilience",permalink:"/redux-offline/docs/basics/write-resilience",editUrl:"https://github.com/redux-offline/redux-offline/blob/develop/docs/basics/write-resilience.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,title:"Write Resilience"},sidebar:"tutorialSidebar",previous:{title:"Read Resilience",permalink:"/redux-offline/docs/basics/read-resilience"},next:{title:"Rollback",permalink:"/redux-offline/docs/basics/rollback"}},u=[{value:"That&#39;s all she wrote",id:"thats-all-she-wrote",children:[],level:2}],f={toc:u};function p(e){var t=e.components,n=(0,i.Z)(e,o);return(0,a.kt)("wrapper",(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"thats-all-she-wrote"},"That's all she wrote"),(0,a.kt)("p",null,"Persisting and rehydrating state (which is a term we use for reading the state back from the disk and into our store) will get us ",(0,a.kt)("strong",{parentName:"p"},"Read"),"-resilience. Our app will work offline as long as the user only wants to read from the state. We also want to support ",(0,a.kt)("strong",{parentName:"p"},"Write"),"-resilience: the user should be able to do (some) actions while offline, and be able to safely assume that they will eventually be reconciled and sent to our backend."),(0,a.kt)("p",null,"In order to support Write-resilience, we will store all network-bound actions in a queue inside our store. Redux Offline creates a state subtree called ",(0,a.kt)("inlineCode",{parentName:"p"},"offline")," where, among other internal state needed by the library, it manages an array called ",(0,a.kt)("inlineCode",{parentName:"p"},"outbox"),"."),(0,a.kt)("p",null,"To be able to perform the network-bound actions after we come back online, we need to store all necessary data to perform the action, and metadata about what should happen afterwards. Redux Offline understands the following metadata:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-diff"},"type OfflineAction = {\n  type: string,\n  payload: any,\n+ meta: {\n+   offline: {\n+     effect: any,\n+     commit: Action,\n+     rollback: Action\n+   }\n+ }\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"meta.offline.effect")," is any data you want to send to the reconciler"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"meta.offline.commit")," action will be fired once the network effect has been successfully sent"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"meta.offline.rollback")," action will be fired if the network effect ",(0,a.kt)("strong",{parentName:"li"},"permanently")," fails (does not count network-related failures, which will be automatically retried)")))}p.isMDXComponent=!0}}]);