"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[533],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return p}});var r=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),d=u(n),p=i,h=d["".concat(s,".").concat(p)]||d[p]||f[p]||o;return n?r.createElement(h,a(a({ref:t},c),{},{components:n})):r.createElement(h,a({ref:t},c))}));function p(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:i,a[1]=l;for(var u=2;u<o;u++)a[u]=n[u];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4094:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return c},default:function(){return d}});var r=n(7462),i=n(3366),o=(n(7294),n(3905)),a=["components"],l={sidebar_position:3},s="config",u={unversionedId:"api/config",id:"api/config",isDocsHomePage:!1,title:"config",description:"Redux Offline supports the following configuration properties:",source:"@site/docs/api/config.md",sourceDirName:"api",slug:"/api/config",permalink:"/redux-offline/docs/api/config",editUrl:"https://github.com/redux-offline/redux-offline/blob/develop/docs/api/config.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"createOffline()",permalink:"/redux-offline/docs/api/createOffline"},next:{title:"Troubleshooting",permalink:"/redux-offline/docs/troubleshooting"}},c=[{value:"defaultCommit",id:"defaultcommit",children:[],level:2},{value:"defaultRollback",id:"defaultrollback",children:[],level:2},{value:"detectNetwork",id:"detectnetwork",children:[],level:2},{value:"discard",id:"discard",children:[],level:2},{value:"effect",id:"effect",children:[],level:2},{value:"offlineStateLens",id:"offlinestatelens",children:[],level:2},{value:"persist",id:"persist",children:[],level:2},{value:"persistAutoRehydrate",id:"persistautorehydrate",children:[],level:2},{value:"persistCallback",id:"persistcallback",children:[],level:2},{value:"persistOptions",id:"persistoptions",children:[],level:2},{value:"queue",id:"queue",children:[{value:"queue.enqueue",id:"queueenqueue",children:[],level:3},{value:"queue.dequeue",id:"queuedequeue",children:[],level:3},{value:"queue.peek",id:"queuepeek",children:[],level:3}],level:2},{value:"retry",id:"retry",children:[],level:2},{value:"returnPromises",id:"returnpromises",children:[],level:2}],f={toc:c};function d(e){var t=e.components,n=(0,i.Z)(e,a);return(0,o.kt)("wrapper",(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"config"},(0,o.kt)("inlineCode",{parentName:"h1"},"config")),(0,o.kt)("p",null,"Redux Offline supports the following configuration properties:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"type Config = {\n  defaultCommit: { type: string },\n  defaultRollback: { type: string },\n  detectNetwork: (callback: NetworkCallback) => void,\n  discard: (error: any, action: OfflineAction, retries: number) => boolean|Promise<boolean>,\n  effect: (effect: any, action: OfflineAction) => Promise<*>,\n  offlineStateLens: (\n    state: any\n  ) => { get: OfflineState, set: (offlineState: ?OfflineState) => any },\n  persist: (store: any, options: {}, callback: () => void) => any,\n  persistAutoRehydrate: (config: ?{}) => (next: any) => any,\n  persistCallback: (callback: any) => any,\n  persistOptions: {},\n  queue: {\n    enqueue: (\n      array: Array<OfflineAction>,\n      item: OfflineAction,\n      context: { offline: OfflineState }\n    ) => Array<OfflineAction>,\n    dequeue: (\n      array: Array<OfflineAction>,\n      item: ResultAction,\n      context: { offline: OfflineState }\n    ) => Array<OfflineAction>,\n    peek: (\n      array: Array<OfflineAction>,\n      item: any,\n      context: { offline: OfflineState }\n    ) => OfflineAction\n  },\n  retry: (action: OfflineAction, retries: number) => ?number,\n  returnPromises: boolean\n};\n")),(0,o.kt)("h2",{id:"defaultcommit"},"defaultCommit"),(0,o.kt)("p",null,"The default action to be dispatched when an offline action is successfully resolved. This is only used when there is not a commit action defined on a offline action."),(0,o.kt)("p",null,"The default action has its payload set to the result of the effects reconciler just as a normal commit action would."),(0,o.kt)("h2",{id:"defaultrollback"},"defaultRollback"),(0,o.kt)("p",null,"The default action to be dispatched when an offline action is discarded. This is only used when there is not a rollback action defined on a offline action."),(0,o.kt)("p",null,"The default action has its payload set to the error thrown by the effects reconciler just as a normal rollback action would."),(0,o.kt)("h2",{id:"detectnetwork"},"detectNetwork"),(0,o.kt)("p",null,"Responsible for communicating network status changes to Redux Offline through the provided callback."),(0,o.kt)("p",null,"The function is passed a callback, which you should call with boolean ",(0,o.kt)("inlineCode",{parentName:"p"},"true")," when the app gets back online, and ",(0,o.kt)("inlineCode",{parentName:"p"},"false")," when it goes offline. Additionally you can call it with an object containing as props ",(0,o.kt)("inlineCode",{parentName:"p"},"online")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"netInfo"),". The ",(0,o.kt)("inlineCode",{parentName:"p"},"online")," is a boolean that defines whether there's connection or not, the ",(0,o.kt)("inlineCode",{parentName:"p"},"netInfo")," is an optional object containing details about the current network."),(0,o.kt)("p",null,"The default ",(0,o.kt)("em",{parentName:"p"},"detectNetwork.js")," provides an object with ",(0,o.kt)("inlineCode",{parentName:"p"},"online")," as the only property."),(0,o.kt)("p",null,"The default ",(0,o.kt)("em",{parentName:"p"},"detectNetwork.native.js")," provides both the ",(0,o.kt)("inlineCode",{parentName:"p"},"online")," and the ",(0,o.kt)("inlineCode",{parentName:"p"},"netInfo")," props following ",(0,o.kt)("inlineCode",{parentName:"p"},"react-native")," netInfo possible values. The payload object would follow the following example:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"/**\n* netInfo reach values follow react-native's NetInfo values\n* Cross-platform: ['none', 'wifi', 'cellular', 'unknown']\n* Android: ['bluetooth', 'ethernet', 'wimax']\n*/\nconst payload = {\n  online: true, // determines the connection status\n  netInfo: {\n    reach: 'wifi', // network reach as provided by react native\n    isConnectionExpensive: false // whether connection is metered (only supported by android)\n  }\n};\n")),(0,o.kt)("h2",{id:"discard"},"discard"),(0,o.kt)("p",null,"Decides whether a request should be retried or not. Tightly coupled with ",(0,o.kt)("inlineCode",{parentName:"p"},"config.effect"),"."),(0,o.kt)("p",null,"Receives the rejection error from ",(0,o.kt)("inlineCode",{parentName:"p"},"config.effect"),", the related offline action, and the number of times the request has been retried. Returns or resolves to a boolean representing if the action should be discarded (as opposed to retried)."),(0,o.kt)("p",null,"The default implementation discards only on client errors."),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"/docs/recepies/customize-requests"},"Customize Requests")," for more details."),(0,o.kt)("h2",{id:"effect"},"effect"),(0,o.kt)("p",null,"The effect reconciler resolves offline actions to network requests."),(0,o.kt)("p",null,"Called with ",(0,o.kt)("inlineCode",{parentName:"p"},"action.meta.offline.effect")," and the action itself, this method must return a Promise. Resolve the promise if the request is a success and reject otherwise. If rejected, the error will be used by ",(0,o.kt)("inlineCode",{parentName:"p"},"config.discard")," to decide whether to attempt the request again."),(0,o.kt)("p",null,"See ",(0,o.kt)("a",{parentName:"p",href:"/docs/recepies/customize-requests"},"Customize Requests")," for more details."),(0,o.kt)("h2",{id:"offlinestatelens"},"offlineStateLens"),(0,o.kt)("p",null,"Determines how the offline state is accessed and updated."),(0,o.kt)("p",null,"The default implementation:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"(state: any) => {\n  const { offline, ...rest } = state;\n  return {\n    get: offline,\n    set: (offlineState: any) =>\n      typeof offlineState === 'undefined'\n        ? rest\n        : { offline: offlineState, ...rest }\n  };\n};\n")),(0,o.kt)("h2",{id:"persist"},"persist"),(0,o.kt)("p",null,"Maintain a copy of the state in some persistent storage."),(0,o.kt)("p",null,"Redux Offline uses ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rt2zz/redux-persist/tree/v4"},"Redux Persist v4")," by default. It is not recommended to write your own implementation for this feature. You can, however, pass a falsey value to prevent the state from being persisted."),(0,o.kt)("h2",{id:"persistautorehydrate"},"persistAutoRehydrate"),(0,o.kt)("p",null,"Store enhancer that loads persisted state."),(0,o.kt)("p",null,"Redux Offline uses the default implementation from ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rt2zz/redux-persist/tree/v4"},"Redux Persist v4"),". It is not recommended that you replace this function."),(0,o.kt)("h2",{id:"persistcallback"},"persistCallback"),(0,o.kt)("p",null,"Called when the state has been rehydrated."),(0,o.kt)("p",null,"Rehydration is fast but not instantaneous, so it is a good idea to delay rendering until the store has been rehydrated."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"const persistCallback = () => {\n  ReactDOM.render(\n    document.getElementById('root'),\n    <Provider store={store}>\n      <MyApp />\n    </Provider>\n  );\n}\n")),(0,o.kt)("h2",{id:"persistoptions"},"persistOptions"),(0,o.kt)("p",null,"Config object provided to ",(0,o.kt)("inlineCode",{parentName:"p"},"config.persist")," as follows:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"config.persist(store, config.persistOptions, config.persistCallback);\n")),(0,o.kt)("p",null,"For details on the available options, refer to the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/rt2zz/redux-persist/tree/v4#persiststorestore-config-callback"},"Redux Persist v4 docs"),";"),(0,o.kt)("h2",{id:"queue"},"queue"),(0,o.kt)("p",null,"Configure how offline actions are stored, accessed, and discarded."),(0,o.kt)("h3",{id:"queueenqueue"},"queue.enqueue"),(0,o.kt)("p",null,"Save an offline action when it is first dispatched."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-js"},"import defaultQueue from '@redux-offline/redux-offline/lib/defaults/queue';\n\nconst getMethod = action => action.meta.offline.effect.method || \"GET\";\nconst getUrl = action => action.meta.offline.effect.url;\n\n// Last Value Queue\n// Only keep the last action for each URL-method pair.\nconst config = {\n  queue: {\n    ...defaultQueue,\n    enqueue(array, action) {\n      const newArray = array.filter(item =>\n        !(getMethod(item) === getMethod(action) && getUrl(item) === getUrl(action))\n      );\n      newArray.push(action);\n      return newArray;\n    }\n  }\n};\n")),(0,o.kt)("h3",{id:"queuedequeue"},"queue.dequeue"),(0,o.kt)("p",null,"Remove an offline action when it has been successfully resolved or discarded."),(0,o.kt)("h3",{id:"queuepeek"},"queue.peek"),(0,o.kt)("p",null,"Retrieve the next offline action to be resolved."),(0,o.kt)("h2",{id:"retry"},"retry"),(0,o.kt)("p",null,"Determine the delay for retrying requests."),(0,o.kt)("p",null,"Accepts the offline action representing the request and the number of times already attempted. Returns either the number of milliseconds to wait before retrying, or ",(0,o.kt)("inlineCode",{parentName:"p"},"null")," if the action should be discarded."),(0,o.kt)("p",null,"The default implementation uses the following schedule to retry requests:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"After 1 seconds"),(0,o.kt)("li",{parentName:"ul"},"After 5 seconds"),(0,o.kt)("li",{parentName:"ul"},"After 15 seconds"),(0,o.kt)("li",{parentName:"ul"},"After 30 seconds"),(0,o.kt)("li",{parentName:"ul"},"After 1 minute"),(0,o.kt)("li",{parentName:"ul"},"After 3 minutes"),(0,o.kt)("li",{parentName:"ul"},"After 5 minutes"),(0,o.kt)("li",{parentName:"ul"},"After 10 minutes"),(0,o.kt)("li",{parentName:"ul"},"After 30 minutes"),(0,o.kt)("li",{parentName:"ul"},"After 1 hour")),(0,o.kt)("p",null,"If a request fails after this point, it will be discarded."),(0,o.kt)("h2",{id:"returnpromises"},"returnPromises"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"WARNING: This is an experimental feature and might change.")),(0,o.kt)("p",null,"Toggle whether dispatch returns promises for offline actions. Defaults to false."),(0,o.kt)("p",null,(0,o.kt)("inlineCode",{parentName:"p"},"store.dispatch()")," returns a promise that you can use to chain behavior off offline actions, but be careful! A chief benefit of this library is that requests are tried across sessions, but promises do not last that long. So if you use this feature, know that your promise might not get resolved, even if the associated request is eventually delivered."))}d.isMDXComponent=!0}}]);