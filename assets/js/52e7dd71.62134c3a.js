"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[448],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return d}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),s=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},p=function(e){var t=s(e.components);return r.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},f=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),f=s(n),d=o,m=f["".concat(c,".").concat(d)]||f[d]||u[d]||i;return n?r.createElement(m,a(a({ref:t},p),{},{components:n})):r.createElement(m,a({ref:t},p))}));function d(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=f;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:o,a[1]=l;for(var s=2;s<i;s++)a[s]=n[s];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}f.displayName="MDXCreateElement"},259:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return l},contentTitle:function(){return c},metadata:function(){return s},toc:function(){return p},default:function(){return f}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),a=["components"],l={sidebar_position:4,title:"Rollback"},c=void 0,s={unversionedId:"basics/rollback",id:"basics/rollback",isDocsHomePage:!1,title:"Rollback",description:"Optimism will get you places",source:"@site/docs/basics/rollback.md",sourceDirName:"basics",slug:"/basics/rollback",permalink:"/redux-offline/docs/basics/rollback",editUrl:"https://github.com/redux-offline/redux-offline/blob/develop/docs/basics/rollback.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,title:"Rollback"},sidebar:"tutorialSidebar",previous:{title:"Write Resilience",permalink:"/redux-offline/docs/basics/write-resilience"},next:{title:"Commit",permalink:"/redux-offline/docs/basics/commit"}},p=[{value:"Optimism will get you places",id:"optimism-will-get-you-places",children:[],level:2}],u={toc:p};function f(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"optimism-will-get-you-places"},"Optimism will get you places"),(0,i.kt)("p",null,"When the initial action has been dispatched, you can update your application state in your reducers as you normally would."),(0,i.kt)("p",null,"A common pattern for offline-friendly apps is to ",(0,i.kt)("em",{parentName:"p"},"optimistically update  UI state"),". In practice, this means that as soon as a user performs an action, we update the UI to look as if the action had already succeeded. This makes our applications resilient to network latency, and improves the perceived performance of our app."),(0,i.kt)("p",null,"When we optimistically update state, we need to ensure that if the action does permanently fail, the user is appropriately notified and the application state is rolled back. To allow you this opportunity, Redux Offline will fire the action you specified in ",(0,i.kt)("inlineCode",{parentName:"p"},"meta.offline.rollback"),". The error object returned by the effects reconciler will be set as the payload."),(0,i.kt)("p",null,"An example of an optimistic update:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-js"},"const action = userId => ({\n  type: 'FOLLOW_USER',\n  payload: { userId },\n  meta: {\n    offline: {\n      effect: //...,\n      rollback: { type: 'FOLLOW_USER_ROLLBACK', meta: { userId }}\n     }\n  }\n});\n\n// optimistically update the state, revert on rollback\nconst followingUsersReducer = (state, action) {\n  switch(action.type) {\n    case 'FOLLOW_USER':\n      return { ...state, [action.payload.userId]: true };\n    case 'FOLLOW_USER_ROLLBACK':\n      return omit(state, [action.meta.userId]);\n    default:\n      return state;\n  }\n}\n")))}f.isMDXComponent=!0}}]);