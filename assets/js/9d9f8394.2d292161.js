"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[230],{3905:function(e,t,n){n.d(t,{Zo:function(){return c},kt:function(){return h}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var u=r.createContext({}),l=function(e){var t=r.useContext(u),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},c=function(e){var t=l(e.components);return r.createElement(u.Provider,{value:t},e.children)},f={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,u=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=l(n),h=o,d=p["".concat(u,".").concat(h)]||p[h]||f[h]||i;return n?r.createElement(d,a(a({ref:t},c),{},{components:n})):r.createElement(d,a({ref:t},c))}));function h(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=p;var s={};for(var u in t)hasOwnProperty.call(t,u)&&(s[u]=t[u]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=n[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},9222:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return u},metadata:function(){return l},toc:function(){return c},default:function(){return p}});var r=n(7462),o=n(3366),i=(n(7294),n(3905)),a=["components"],s={sidebar_position:5,title:"Troubleshooting"},u=void 0,l={unversionedId:"troubleshooting",id:"troubleshooting",isDocsHomePage:!1,title:"Troubleshooting",description:"Offline queue doesn't trigger on network status change",source:"@site/docs/troubleshooting.md",sourceDirName:".",slug:"/troubleshooting",permalink:"/redux-offline/docs/troubleshooting",editUrl:"https://github.com/redux-offline/redux-offline/blob/develop/docs/troubleshooting.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5,title:"Troubleshooting"},sidebar:"tutorialSidebar",previous:{title:"config",permalink:"/redux-offline/docs/api/config"}},c=[{value:"Offline queue doesn&#39;t trigger on network status change",id:"offline-queue-doesnt-trigger-on-network-status-change",children:[{value:"TL;DR - The fix",id:"tldr---the-fix",children:[],level:3},{value:"Why",id:"why",children:[],level:3}],level:2}],f={toc:c};function p(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},f,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"offline-queue-doesnt-trigger-on-network-status-change"},"Offline queue doesn't trigger on network status change"),(0,i.kt)("p",null,"If you have actions in your redux-offline queue, all of them should be dispatched as soon as your app goes online again."),(0,i.kt)("p",null,"If you experience the queue ",(0,i.kt)("em",{parentName:"p"},"doesn't")," execute, then this guide will explain how to fix it, and why it works."),(0,i.kt)("h3",{id:"tldr---the-fix"},"TL;DR - The fix"),(0,i.kt)("p",null,"For you in a hurry; The error is caused by your redux store getting configured incorrectly, when you you use the ",(0,i.kt)("inlineCode",{parentName:"p"},"createOffline")," function instead of using the default setup."),(0,i.kt)("p",null,"When composing your store's enhances, the offlineEnhancer ",(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("em",{parentName:"strong"},"MUST"))," come first."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Example of a correctly configured store")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-javascript"},"// redux-configuration.js\n\nconst reduxOfflineConfiguration = { /*config stuff*/ };\nconst initialState = {};\nconst offlineEnhancer = createOffline(reduxOfflineConfiguration);\nfunction rootReducer() {\n  // Root reducer code\n}\n\nconst store = createStore(\n    offlineEnhancer.enhanceReducer(rootReducer),\n    initialState,\n    compose(\n        offlineEnhancer.enhanceStore, // <-- The offline enhancer comes first. Your queue will execute just fine :)\n        applyMiddleware(offlineEnhancer.middleware)\n    )\n);\n")),(0,i.kt)("h3",{id:"why"},"Why"),(0,i.kt)("p",null,"The reason why the store configuration needs to be as described above is very well explained by github user @j8seangel in this issue: ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/forest-watcher/forest-watcher/pull/303"},"Fix offline not starting after rehydrate")," (He's also the original author of above fix). I'll quote his answer here:"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Order matters, swapping two words could fix a critical bug \ud83c\udf89"),(0,i.kt)("p",{parentName:"blockquote"},"The offline middleware wasn't aware of the outbox actions after rehydrate until another action was dispatched, so when the app starts and it doesn't dispatch any other action the offline wouldn't start and the actions would remain there forever."),(0,i.kt)("p",{parentName:"blockquote"},"Now the middleware is applied first and all of the actions go through it, including the rehydrate one."),(0,i.kt)("p",{parentName:"blockquote"},"Reference: ",(0,i.kt)("a",{parentName:"p",href:"https://redux.js.org/api-reference/compose"},"https://redux.js.org/api-reference/compose"),"\nKey: ",(0,i.kt)("inlineCode",{parentName:"p"},"Composes functions from right to left."))),(0,i.kt)("p",null,"Also, @sorodrigo explains the problem AND solution quite exact ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/redux-offline/redux-offline/pull/229"},"here")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"The redux-offline peeks the offlineAction to process everytime an action goes through the middleware chain. This works fine for actions dispatched in the same session. However when the store gets rehydrated if there's actions on the outbox, these will remain there until an action is dispatched. This is because, the offline middleware is registered after the persist has been configured so the PERSIST_REHYDRATE action doesn't trigger the offline process."),(0,i.kt)("p",{parentName:"blockquote"},"The solution is to simply apply middleware before enhancing the store.")),(0,i.kt)("p",null,"If this doesn't fix your queue not executing, open an issue :)"),(0,i.kt)("p",null,"Happy programming!"))}p.isMDXComponent=!0}}]);